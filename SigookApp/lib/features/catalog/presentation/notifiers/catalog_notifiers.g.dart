// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'catalog_notifiers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Availability Notifier
/// Manages availability catalog data with loading, error, and data states

@ProviderFor(Availability)
const availabilityProvider = AvailabilityProvider._();

/// Availability Notifier
/// Manages availability catalog data with loading, error, and data states
final class AvailabilityProvider
    extends $AsyncNotifierProvider<Availability, List<CatalogItem>> {
  /// Availability Notifier
  /// Manages availability catalog data with loading, error, and data states
  const AvailabilityProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'availabilityProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$availabilityHash();

  @$internal
  @override
  Availability create() => Availability();
}

String _$availabilityHash() => r'b634a123f190ecef6d1668da0468b5b25f7d1ff8';

/// Availability Notifier
/// Manages availability catalog data with loading, error, and data states

abstract class _$Availability extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Availability Time Notifier

@ProviderFor(AvailabilityTime)
const availabilityTimeProvider = AvailabilityTimeProvider._();

/// Availability Time Notifier
final class AvailabilityTimeProvider
    extends $AsyncNotifierProvider<AvailabilityTime, List<CatalogItem>> {
  /// Availability Time Notifier
  const AvailabilityTimeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'availabilityTimeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$availabilityTimeHash();

  @$internal
  @override
  AvailabilityTime create() => AvailabilityTime();
}

String _$availabilityTimeHash() => r'e86cc2e115ba18a0d7ea7e133df6c418a013439c';

/// Availability Time Notifier

abstract class _$AvailabilityTime extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Countries Notifier

@ProviderFor(Countries)
const countriesProvider = CountriesProvider._();

/// Countries Notifier
final class CountriesProvider
    extends $AsyncNotifierProvider<Countries, List<CatalogItem>> {
  /// Countries Notifier
  const CountriesProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'countriesProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$countriesHash();

  @$internal
  @override
  Countries create() => Countries();
}

String _$countriesHash() => r'b75f6c694f302b1b5e8125cf15920f500c5b72f5';

/// Countries Notifier

abstract class _$Countries extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Genders Notifier

@ProviderFor(Genders)
const gendersProvider = GendersProvider._();

/// Genders Notifier
final class GendersProvider
    extends $AsyncNotifierProvider<Genders, List<CatalogItem>> {
  /// Genders Notifier
  const GendersProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'gendersProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$gendersHash();

  @$internal
  @override
  Genders create() => Genders();
}

String _$gendersHash() => r'd5b091fe49ba75997d85d0431392fa79e9876032';

/// Genders Notifier

abstract class _$Genders extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Identification Types Notifier

@ProviderFor(IdentificationTypes)
const identificationTypesProvider = IdentificationTypesProvider._();

/// Identification Types Notifier
final class IdentificationTypesProvider
    extends $AsyncNotifierProvider<IdentificationTypes, List<CatalogItem>> {
  /// Identification Types Notifier
  const IdentificationTypesProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'identificationTypesProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$identificationTypesHash();

  @$internal
  @override
  IdentificationTypes create() => IdentificationTypes();
}

String _$identificationTypesHash() =>
    r'00ce74477be221b1e051eff8dae1766abf7d1e20';

/// Identification Types Notifier

abstract class _$IdentificationTypes extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Languages Notifier

@ProviderFor(Languages)
const languagesProvider = LanguagesProvider._();

/// Languages Notifier
final class LanguagesProvider
    extends $AsyncNotifierProvider<Languages, List<CatalogItem>> {
  /// Languages Notifier
  const LanguagesProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'languagesProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$languagesHash();

  @$internal
  @override
  Languages create() => Languages();
}

String _$languagesHash() => r'e2be49574f1c10e83fbaa14a7c8c09ce4d54a5a0';

/// Languages Notifier

abstract class _$Languages extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Skills Notifier

@ProviderFor(Skills)
const skillsProvider = SkillsProvider._();

/// Skills Notifier
final class SkillsProvider
    extends $AsyncNotifierProvider<Skills, List<CatalogItem>> {
  /// Skills Notifier
  const SkillsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'skillsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$skillsHash();

  @$internal
  @override
  Skills create() => Skills();
}

String _$skillsHash() => r'b6fe1ad441455e9a757a5291ee05bbd445cad1fa';

/// Skills Notifier

abstract class _$Skills extends $AsyncNotifier<List<CatalogItem>> {
  FutureOr<List<CatalogItem>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref =
        this.ref as $Ref<AsyncValue<List<CatalogItem>>, List<CatalogItem>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<CatalogItem>>, List<CatalogItem>>,
              AsyncValue<List<CatalogItem>>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
